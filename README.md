# Bokoa

## Brain-Teaser Game

### Brief Presentation
This game is a brain teaser game in which the goal is to reach the highest possible score using a grid of operations.<br>
It is not mandatory to use every case of the grid, and a case can only be used once.<br>
Every game starts with a score of one, then each time an operation is applied, the score is modified.<br>
Operations are addition, multiplication, division and substraction.<br>
Each case contains an operation and an operand (whose magnitude can go up to 5)<br>
Each level has a maximum score; the goal is to find it.<br>
For now, the game contains 3 different grid sizes : 4x4, 5x5 and 6x6.<br>

### Example of Gameplay
Short Example Of Gameplay : https://www.youtube.com/watch?v=BFgg8Upa_28<br>

### Origin Of The Name
Origin of the name : <br>
- Japanese of case/box: Bokusu<br>
- Japanese of Score: Sukoa<br>

### Available for android
The game is currently available for Android; you can download it on the Play Store: <br>
https://play.google.com/store/apps/details?id=com.slykos.bokoa<br>


## Technical details

This repository is divided into two parts :<br>
- Level Generator : generates a set of levels to avoid the Android Application heavy computation.<br>
- Android App : Android Studio project that implements the game, using the levels generated by the Level Generator.<br>

### Level Generator
The Level Generator is a project in python which generates levels in a .json format.<br>
The Level Generator is divided into two main scripts: create_levels and prepare_levels.<br>

#### Initial creation
For each grid size, a large number of levels is generated.<br>

##### Best Score And Best Solution Search
The strategy here is to try every possible solution, and keep the set of moves that leads to the highest score.<br>
For the first two grid sizes, the script is quite fast<br>
As expected, this script is computationally heavy for the biggest grid size, 6x6.<br>
In the current set-up, it takes around 42 seconds (on a modern computer) to generate one level and find its solution<br>
- In the current set-up, 1000 levels are initially generated, so roughly 12 hours<br>
- This can be accelerated by using multi-core, depending on the machine.<br>

#### Levels Preparation
The goal of this section is to process each of these 4 steps : 

##### Duplicate checks
There is a probability (low, but not 0) that the same level has been generated several times.<br>
For that reason, the initial set of levels goes through a function that checks for duplicates and removes the duplicated ones.<br>

##### Extreme Removal
Some levels will have what we will refer to as "Extreme" solution, i.e. a solution that is either very long, very short, leads to a score that is very high, or very low. <br>
An  exaggerated example would be a level whose best solution is 1. That would mean that any solution would reduce the score below 1.<br>
As those levels would not be interesting to solve, they are simply removed.<br>
Arbitrarily, the top 10 percent lowest, highest score are removed (same with levels sizes, in number of moves)<br>

##### Difficulty
The difficulty of each level is then estimated. It is not an easy task, as it is quite subtle (what is a difficult level?).<br>
The levels have a parameter called estimated_difficulty, which is a float between 0 and 1<br>
For now, this is a combination of two factors: <br>
- How much operations (in proportion to the length of the solution) increase the score (The idea is that a difficult solution will be counter-intuitive, taking multiple operations that diminish the score)<br>
- How much the score will decrease through the best solution (in that case, we only look at the "negatives" operations) (again, the idea is that a best solution that goes through a lot of diminution will be hard to see).<br>

##### Reduced set of levels + sort
Out of the remaining levels at that point, a selection of a fixed amount is done.<br>
This selection is done by taking the closest estimated_difficulty to an "ideal line" that will ascend constantly from 0 to one.<br>
The remaining levels are thus, in theory, of increasing difficulty, more precisely of a constantly increasing difficulty.<br>

### Android Application
Android Studio Project, using Kotlin, that uses the levels in JSON files produced by the level generator<br>
